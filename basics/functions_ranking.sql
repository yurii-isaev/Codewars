/*
Функции ранжирования являются не детерминированными,
то есть при одних и тех же входных значениях они могут возвращать разный результат.

На данный момент имеется 4 функции ранжирования:
ROW_NUMBER()
Эта функция нумерует записи в указанном порядке внутри "окна". Но если в конструкции OVER опустить секцию PARTITION BY,
то за "окно" будет принята вся выборка - что дает возможность пронумеровать все записи в должном порядке.
Причем порядок нумерации может не совпадать с порядком записей в результирующей выборке,
то есть оператор ORDER BY внутри OVER(…), определяющий порядок сортировки записей внутри "окна",
и, соответственно, порядок нумерации записей может не совпадать с оператором ORDER BY в конструкции SELECT,
определяющей порядок выдачи записей клиенту. Нумерация всегда начинается с единицы.

RANK()
Эта функция предназначена для ранжирования записей внутри "окна",
но опять-таки, если колонка для группировки не задана явным образом,
то за "окно" принимается вся выборка. Это та же нумерация, что и в ROW_NUMBER(), которая начинается с той же единицы.
Различие в том, что одинаковые записи получают одинаковый номер,
а следующая отличающаяся от них запись получает такой номер, как если бы ROW_NUMBER() и использовалась,
и все предыдущие записи получили свои уникальные номера.
  Таким образом, образуется дырка в нумерации, равная количеству одинаковых записей минус единица.

DENSE_RANK()
Эта функция выполняет "плотное" ранжирование,
то есть делает ровно то же самое, что и предыдущая, но без дырок" в нумерации.

NTILE()
Данная функция позволяет разделить записи внутри "окна" на указанное количество групп.
Для каждой записи она вернет номер группы, к которой принадлежит данная запись.
Нумерация групп также начинается с единицы.
Если количество записей в "окне" не делится на количество групп,
то получится два типа групп с разным количеством записей, отличающимся на единицу,
при этом сначала будут выведены группы с большим количеством записей, а затем - с меньшим.
 */

USE AdventureWorks2014;

-- Нумеруем все строки в таблице по убыванию ключа LineTotal.
SELECT *,
       ROW_NUMBER() over (ORDER BY LineTotal DESC) AS NO
FROM Sales.SalesOrderDetail
GO

-- Если строки нумерации повторяются в таблице по убыванию ключа LineTotal,
-- то такие строки будут сортироваться по второму ключу SalesOrderDetailID по возрастанию.
SELECT *,
    ROW_NUMBER() over (ORDER BY LineTotal DESC, SalesOrderDetailID) AS NO
FROM Sales.SalesOrderDetail
GO

SELECT *,
       ROW_NUMBER() over (PARTITION BY SalesOrderID ORDER BY LineTotal) AS NO
FROM Sales.SalesOrderDetail
GO

USE test;

CREATE TABLE Металлы
(
    [Название (RU)]             NVARCHAR(20),
    [Название (LAT)]            NVARCHAR(20),
    [Химическое обозначение]    NVARCHAR(5),
    [Атомный вес]               DECIMAL(8, 4),
    [Температура плавления, °С] DECIMAL(6, 1),
    [Удельный вес, г/куб.см]    DECIMAL(8, 5)
)
INSERT INTO Металлы
VALUES ('Цинк', 'Zinc', 'Zn', 65.37, 419.5, 7.13),
       ('Алюминий', 'Aluminium', 'Al', 26.985, 659, 2.69808),
       ('Свинец', 'Lead', 'Pb', 207.19, 375.4, 11.337),
       ('Олово', 'Tin', 'Sn', 118.69, 231.9, 7.29),
       ('Медь', 'Cooper', 'Cu', 63.54, 1083, 8.96),
       ('Титан', 'Titanium', 'Ti', 47, 1668, 4.5),
       ('Никель', 'Nickel', 'Ni', 58.71, 1455, 8.91),
       ('Магний', 'Magnesium', 'Mg', 24, 650, 1.74),
       ('Ванадий', 'Vanadium', 'V', 6, 1900, 6.11),
       ('Вольфрам', 'Wolfram', 'W', 51, 1765, 7.19)
GO

-- Создание дубликатов металлов с атомным весом между 100 и 200.
INSERT INTO Металлы
SELECT *
FROM Металлы
WHERE [Атомный вес] BETWEEN 60 AND 200
GO

-- Найти повторяющтеся строки.
SELECT [Название (RU)],
       [Название (LAT)],
       [Химическое обозначение],
       [Атомный вес],
       COUNT(*) [Количество повторов]
FROM Металлы
GROUP BY [Название (RU)],
         [Название (LAT)],
         [Химическое обозначение],
         [Атомный вес]
HAVING COUNT(*) > 1
GO

-- Найти конкретные строки, при вотронении номера от 2.
SELECT ROW_NUMBER() over (PARTITION BY [Название (RU)]
    ORDER BY [Название (RU)]) AS No,
       [Название (RU)],
       [Название (LAT)],
       [Химическое обозначение],
       [Атомный вес]
FROM Металлы
GO

-- ВЫберем повторяющтеся строки при помощи производной таблицы.
SELECT *
FROM (SELECT ROW_NUMBER() over (
    PARTITION BY [Название (RU)]
    ORDER BY [Название (RU)]) AS No,
             [Название (RU)],
             [Название (LAT)],
             [Химическое обозначение],
             [Атомный вес]
      FROM Металлы) AS DT
WHERE No > 1
GO

-- ВЫберем повторяющтеся строки при помощи обобщенного табличного выражения.
WITH CTE AS (SELECT ROW_NUMBER() over (
    PARTITION BY [Название (RU)]
    ORDER BY [Название (RU)]) AS No,
                 [Название (RU)],
                 [Название (LAT)],
                 [Химическое обозначение],
                 [Атомный вес]
             FROM Металлы)
SELECT *
FROM CTE
WHERE No > 1
GO

-- Удалим повторяющтеся строки при помощи обобщенного табличного выражения.
WITH CTE AS (SELECT ROW_NUMBER() over (
    PARTITION BY [Название (RU)]
    ORDER BY [Название (RU)]) AS No,
                 [Название (RU)],
                 [Название (LAT)],
                 [Химическое обозначение],
                 [Атомный вес]
             FROM Металлы)
DELETE
FROM CTE
WHERE No > 1
GO
